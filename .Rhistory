yaxt = "n",
pch = 21)
plot(rep(0, nobs) ~ yields$yield,
col = level.0.block,
ylim = c(-0.1, 3.1),
xlim = c(min(yields$yield) - 1, max(yields$yield) + 1),
bty = "L",
yaxt = "n",
pch = 19)
?points
axis(2, at = 0:3, las = 1)
# plot the means at level 1
points(rep(1, length(level.1.mu)) ~ level.1.mu,
col = level.1.block,
pch = 20)
# plot the means at level 2
points(rep(2, length(level.2.mu)) ~ level.2.mu,
col = level.2.block,
pch = 20)
# plot the means at level 3
points(rep(3, length(level.3.mu)) ~ level.3.mu,
col = level.3.block,
pch = 20)
# add the overall mean
abline(v = mean(yields$yield), lty = 2, lwd = 2, col = 5)
abline(v = mean(yields$yield), lty = 2, lwd = 2, col = "grey")
?jitter
plot(jitter(rep(0, n), 0.1) ~ yields$yield,
col = level.0.block,
ylim = c(-0.1, 3.1),
xlim = c(min(yields$yield) - 1, max(yields$yield) + 1),
bty = "L",
yaxt = "n",
pch = 20)
axis(2, at = 0:3, las = 1)
jitter(rep(0, n), 0.1)
# plot the raw data, i.e. level 0, with a bit of jitter
plot(jitter(rep(0, n), 0.1) ~ yields$yield,
col = level.0.block,
ylim = c(-0.1, 3.1),
xlim = c(min(yields$yield) - 1, max(yields$yield) + 1),
bty = "L",
yaxt = "n",
pch = 20)
plot(jitter(rep(0, nobs), 0.1) ~ yields$yield,
col = level.0.block,
ylim = c(-0.1, 3.1),
xlim = c(min(yields$yield) - 1, max(yields$yield) + 1),
bty = "L",
yaxt = "n",
pch = 20)
axis(2, at = 0:3, las = 1)
plot(jitter(rep(0, nobs), 0.2) ~ yields$yield,
col = level.0.block,
ylim = c(-0.1, 3.1),
xlim = c(min(yields$yield) - 1, max(yields$yield) + 1),
bty = "L",
yaxt = "n",
pch = 20)
axis(2, at = 0:3, las = 1)
plot(jitter(rep(0, nobs), 0.3) ~ yields$yield,
col = level.0.block,
ylim = c(-0.1, 3.1),
xlim = c(min(yields$yield) - 1, max(yields$yield) + 1),
bty = "L",
yaxt = "n",
pch = 20)
axis(2, at = 0:3, las = 1)
# plot the means at level 1
points(runif(length(level.1.mu), -0.9, 1.1) ~ level.1.mu,
col = level.1.block,
pch = 20)
?jitter
plot(jitter(rep(0, nobs), amount = 0.1) ~ yields$yield,
col = level.0.block,
ylim = c(-0.1, 3.1),
xlim = c(min(yields$yield) - 1, max(yields$yield) + 1),
bty = "L",
yaxt = "n",
pch = 20)
axis(2, at = 0:3, las = 1)
palette(viridis(length(level.3.mu)))
# number of observaitons in our dataset
nobs <- nrow(yields)
# for adding colour to the plot, and to track block all the way
# down to level 0, we extract the appropriate block code.
level.0.block <- yields$block
level.1.block <- tapply(yields$block, level.1, function(x){x[1]})
level.2.block <- tapply(yields$block, level.2, function(x){x[1]})
level.3.block <- tapply(yields$block, level.3, function(x){x[1]})
# plot the raw data, i.e. level 0, with a bit of jitter
plot(jitter(rep(0, nobs), amount = 0.1) ~ yields$yield,
col = level.0.block,
ylim = c(-0.1, 3.1),
xlim = c(min(yields$yield) - 1, max(yields$yield) + 1),
bty = "L",
yaxt = "n",
pch = 20)
axis(2, at = 0:3, las = 1)
# plot the means at level 1
points(jitter(rep(1, length(level.1.mu)), amount = 0.1) ~ level.1.mu,
col = level.1.block,
pch = 20)
# plot the means at level 2
points(jitter(rep(2, length(level.2.mu)), amount = 0.1) ~ level.2.mu,
col = level.2.block,
pch = 20)
# plot the means at level 3
points(jitter(rep(3, length(level.3.mu)), amount = 0.1) ~ level.3.mu,
col = level.3.block,
pch = 20)
# add the overall mean
abline(v = mean(yields$yield), lty = 2, lwd = 2, col = "grey")
# ------------------------------------------------------------
palette(viridis(length(level.3.mu)))
# number of observaitons in our dataset
nobs <- nrow(yields)
# for adding colour to the plot, and to track block all the way
# down to level 0, we extract the appropriate block code.
level.0.block <- yields$block
level.1.block <- tapply(yields$block, level.1, function(x){x[1]})
level.2.block <- tapply(yields$block, level.2, function(x){x[1]})
level.3.block <- tapply(yields$block, level.3, function(x){x[1]})
jit <- 0.15
# plot the raw data, i.e. level 0, with a bit of jitter
plot(jitter(rep(0, nobs), amount = jitt) ~ yields$yield,
col = level.0.block,
ylim = c(-0.1, 3.1),
xlim = c(min(yields$yield) - 1, max(yields$yield) + 1),
jt <- 0.15
# plot the raw data, i.e. level 0, with a bit of jitter
plot(jitter(rep(0, nobs), amount = jt) ~ yields$yield,
col = level.0.block,
ylim = c(-0.1, 3.1),
xlim = c(min(yields$yield) - 1, max(yields$yield) + 1),
bty = "L",
yaxt = "n",
pch = 20)
axis(2, at = 0:3, las = 1)
jt <- 0.15
# plot the raw data, i.e. level 0, with a bit of jitter
plot(jitter(rep(0, nobs), amount = jt) ~ yields$yield,
col = level.0.block,
ylim = c(-0.1, 3.1),
xlim = c(min(yields$yield) - 1, max(yields$yield) + 1),
bty = "L",
yaxt = "n",
pch = 20)
axis(2, at = 0:3, las = 1)
# plot the means at level 1
points(jitter(rep(1, length(level.1.mu)), amount = jt) ~ level.1.mu,
col = level.1.block,
pch = 20)
# plot the means at level 2
points(jitter(rep(2, length(level.2.mu)), amount = jt) ~ level.2.mu,
col = level.2.block,
pch = 20)
# plot the means at level 3
points(jitter(rep(3, length(level.3.mu)), amount = jt) ~ level.3.mu,
col = level.3.block,
pch = 20)
# add the overall mean
abline(v = mean(yields$yield), lty = 2, lwd = 2, col = "grey")
# ------------------------------------------------------------
source('~/Documents/Projects/random-snippets/nested-random-intercepts.R', echo=TRUE)
level.variances
yields
summary(m.marginal)
summary(m.nested)
summary(bayes.marginal)
summary(bayes.nested)
summary(m.nested)
summary(m.marginal)
mydata$n_block
mydata$n_density
mydata$n_irrigation
mydata$n
level.variances
source('~/Documents/Projects/random-snippets/nested-random-intercepts.R', echo=TRUE)
summary(lmer(yield ~ 1 + (1|density), data = yields))
summary(lmer(yield ~ 1 + (1|density:irrigation:block), data = yields))
level.variances
?lmer
# Chunk 1: setup
knitr::opts_chunk$set(echo = TRUE)
if(!require(viridis)) install.packages("viridis")
library(viridis)
# Chunk 2: simluate
# set the random seed for reproducibility
set.seed(1)
# sample size per group
n <- 20
# number of groups
g <- 5
G <- factor(rep(LETTERS[1:g], n))
# set the colour palette accordingly (NB i use the library viridis)
palette(viridis(g))
# a slope for each group taken from a normal distribution
mu.b <- 2
s.b <- 3
b <- rnorm(g, mu.b, s.b)
B <- rep(b, n) # and replicate them out for each sample
# an intercept for each group, taken from a normal distribution
mu.c <- 0
s.c <- 2
c <- rnorm(g, mu.c, s.c)
C <- rep(c, n) # and replicate them out for each sample
# The linear covariate X is uniform random between -2 and 2
X <- runif(n*g, -2, 2)
# define the residual noise
s.r <- 1
s <- rnorm(n*g, 0, s.r)
# calculate the reponse variable Y
Y <- X * B + C + s
# Plot the results
plot(Y ~ X, col = G)
dd <- data.frame(Y = Y, X = X, G = G)
dd.s <- split(dd, G)
for (i in 1:length(dd.s)){
abline(lm(Y~X, data = dd.s[[i]]), col = i)
}
# Chunk 3: model
# load the lme4 library
if(!require(lme4, quietly = TRUE)) install.packages("lme4")
library(lme4, quietly = TRUE)
# fixed effects only. 4 slopes and 4 intercepts using glm()
m1 <- glm(Y ~ X * G)
# one slope and random intercept
m2 <- lmer(Y ~ X + (1|G))
# 4 slopes and a random intercept term
m3 <- lmer(Y ~ X + X:G + (1|G))
# random slope and random intercept
m4 <- lmer(Y ~ X + (X|G))
# random slope and random intercept (uncorrelated)
m5 <- lmer(Y ~ X + (X||G))
# Chunk 4: population.values
# collate the specified values from the start
true.coefs <- data.frame(Intercept = c, Slopes.X = b)
print(round(true.coefs,2))
# It is also useful to compare these coefficients to those for Group A,
# since model fitting often compares the effect of the other Groups to this
# baseline, reference group.
relative.coefs <- data.frame(G.effects = c - c[1], Slopes.effects = b - b[1])
print(round(relative.coefs, 2))
# the sample means of these coefficients
print(round(colMeans(true.coefs),2))
# and the population means and variances (which we specified a priori)
cat("Population mean\n")
cat(c(mu.c, mu.b))
cat("Population variances\n")
cat(c(s.c, s.b) ^ 2)
# Chunk 5: compare
# pull out and re-organise the estimates for the glm
tmp <- coef(m1)
glm.est <- data.frame(Intercepts = c(tmp[1], tmp[3:(g+1)]),
Slopes = c(tmp[2], tmp[(g+2):(g+g)]))
rownames(glm.est) <- LETTERS[1:g]
print(glm.est)
# ------------------------------------------------------------
# get estimates for the lmer objects which is much easier
rand.intercepts.1.slope <- coef(m2)$G
print(rand.intercepts.1.slope)
tmp <- coef(m3)$G
rand.inter.4.slopes <- data.frame(Intercept = tmp$`(Intercept)`,
X = unlist(c(tmp[1,2], tmp[1,3:(g+1)] +
tmp[1,2])))
rownames(rand.inter.4.slopes) <- LETTERS[1:g]
print(rand.inter.4.slopes)
# Random slopes and intercepts
rand.slopes <- coef(m4)$G
print(rand.slopes)
# Random slopes and intercepts
rand.slopes.u <- coef(m5)$G
print(rand.slopes.u)
# Chunk 6: variances
# summary of the full random slopes and random intercept model
summary(m4)
# summary of the full uncorrelated random slopes and random intercept model
summary(m5)
# we simulated using standard deviations, so need to square them to get
# variances.
sim.vars <- c(Var.intercepts = s.c ^ 2,
Var.slopes = s.b ^ 2,
Resid.Var = s.r ^ 2)
# Chunk 7: aic
lapply(list(m1, m2, m3, m4, m5), extractAIC)
# Chunk 8: loglik
lapply(list(m1, m2, m3, m4, m5), logLik)
print(rand.slopes)
print(rand.slopes.u)
data(Pastes)
list()
ls()
head(Pastes)
Pastes
yields
unclass(Pastes$sample)
aj<-unclass(Pastes$sample)
names(aj)
aj
head(Pastes)
overall.mean <- mean(Pastes$strength)
level.1.mu <- tapply(Pastes$strength, Pastes$sample, mean)
level.2.mu <- tapply(Pastes$strength, Pastes$batch, mean)
# the variances of those means (and the overall variance)
overall.var <- var(yields$yield)
level.1.var <- var(level.1.mu)
level.2.var <- var(level.2.mu)
# collate the variances among means at each level
# i.e. these are the naive summary random effects.
level.variances <- c(L1 = level.1.var,
L2 = level.2.var,
Overall = overall.var)
# for sake of summary, assume independence of variances, and sum them
# which *should* be close enough to the overall variance unless there
# is loads of covariance among the levels.
ind.var <- sum(level.variances[1:3])
ind.var <- sum(level.variances[1:2])
ind.var
palette(viridis(length(level.2.mu)))
# number of observaitons in our dataset
nobs <- nrow(yields)
level.0.block <- yields$batch
level.1.block <- tapply(yields$batch, level.1, function(x){x[1]})
level.2.block <- tapply(yields$batch, level.2, function(x){x[1]})
jt <- 0.15
level.0.block <- yields$batch
level.0.block <- Pastes$batch
level.1.block <- tapply(Pastes$batch, level.1, function(x){x[1]})
level.2.block <- tapply(Pastes$batch, level.2, function(x){x[1]})
level.0.block <- Pastes$batch
level.1.block <- tapply(Pastes$batch, level.1, function(x){x[1]})
level.0.block <- Pastes$batch
level.1.block <- tapply(Pastes$batch, Pastes$sample, function(x){x[1]})
level.2.block <- tapply(Pastes$batch, Pastes$batch, function(x){x[1]})
jt <- 0.15
# plot the raw data, i.e. level 0, with a bit of jitter
plot(jitter(rep(0, nobs), amount = jt) ~ yields$yield,
col = level.0.block,
plot(jitter(rep(0, nobs), amount = jt) ~ Pastes$strength,
col = level.0.block,
ylim = c(-0.1, 3.1),
xlim = c(min(Pastes$strength) - 1, max(Pastes$strength) + 1),
bty = "L",
yaxt = "n",
pch = 20)
axis(2, at = 0:3, las = 1)
plot(jitter(rep(0, nobs), amount = jt) ~ Pastes$strength,
col = level.0.block,
ylim = c(-0.1, 3.1),
xlim = c(min(Pastes$strength) - 1, max(Pastes$strength) + 1),
bty = "L",
yaxt = "n",
pch = 20)
nobs <- nrow(Pastes)
plot(jitter(rep(0, nobs), amount = jt) ~ Pastes$strength,
col = level.0.block,
ylim = c(-0.1, 3.1),
xlim = c(min(Pastes$strength) - 1, max(Pastes$strength) + 1),
bty = "L",
yaxt = "n",
pch = 20)
# plot the means at level 1
points(jitter(rep(1, length(level.1.mu)), amount = jt) ~ level.1.mu,
col = level.1.block,
pch = 20)
# plot the means at level 2
points(jitter(rep(2, length(level.2.mu)), amount = jt) ~ level.2.mu,
col = level.2.block,
pch = 20)
head(Pastes)
m.nested <- lmer(strength ~ 1 + (1|batch/cask), data = Pastes)
# not-nested random effects
m.marginal <- lmer(strength ~ 1 + (1|batch) + (1|cask),
data = Pastes)
source('~/Documents/Projects/random-snippets/nested-random-effects-pastes.R', echo=TRUE)
source('~/Documents/Projects/random-snippets/nested-random-effects-pastes.R', echo=TRUE)
source('~/Documents/Projects/random-snippets/nested-random-effects-pastes.R', echo=TRUE)
source('~/Documents/Projects/random-snippets/nested-random-effects-pastes.R', echo=TRUE)
hdr(bayes.nested)
hdrcde::hdr(bayes.nested)
?coda
?jags.model
library(coda)
?codamenu
hdrcde::hdr(as.matrix.mcmc(bayes.nested)
)
hdrcde::hdr(coda::as.matrix.mcmc(bayes.nested)
)
hdrcde::hdr(as.matrix(bayes.nested))
head(as.matrix(bayes.nested))
apply(as.matrix(bayes.nested),2,hdrcde::hdr)
densplot(bayes.nested)
level.1.mu
level.1
level1
mydata$level1
data.frame(mydata$level1,mydata$level2,Pastes)
source('~/Documents/Projects/random-snippets/nested-random-effects-pastes.R', echo=TRUE)
data.frame(mydata$level1,mydata$level2,Pastes)
lmer(strength~1 + (1|batch) + (1|sample), data = Pastes)
aj <- lmer(strength~1 + (1|batch) + (1|sample), data = Pastes)
summary(aj)
gelman.diag(bayes.nested)
source('~/Documents/Projects/random-snippets/nested-random-effects-pastes.R', echo=TRUE)
plot(bayes.nested)
source('~/Documents/Projects/random-snippets/nested-random-effects-pastes.R', echo=TRUE)
summary(m.nested)
summary(m.marginal)
summary(bayes.marginal)
summary(bayes.nested)
bayes.nested = coda.samples(model = model,
variable.names = c("b0",
"v_level1",
"v_level2",
"v_resid",
"v_tot"),
n.iter = 5 * 10^4,
thin = 10)
gelman.diag(bayes.nested)
summary(m.nested)
summary(m.marginal)
summary(bayes.marginal)
summary(bayes.nested)
level.variances
gelman.diag(bayes.nested)
apply(as.matrix(bayes.nested),1,hdrcde::hdr)
hdrcde::hdr(as.matrix(bayes.nested)[,2])
hist(as.matrix(bayes.nested)[,2])
hist(as.matrix(bayes.nested)[,1])
density(as.matrix(bayes.nested)[,1])
head(as.matrix(bayes.nested))
?hdrcde::hdr
is.list(bayes.nested)
hdrcde::hdr.boxplot(bayes.nested)
apply(as.matrix(bayes.nested), 1, mean)
apply(as.matrix(bayes.nested), 2, mean)
apply(as.matrix(bayes.nested), 2, function(x){hdrcde::hdr(x)$mode})
hdrcde::hdr(as.matrix(bayes.nested)[,1])
hdrcde::hdr(as.matrix(bayes.nested)[,2])
hdrcde::hdr(as.matrix(bayes.nested)[,3])
hdrcde::hdr(as.matrix(bayes.nested)[,4])
hdrcde::hdr.boxplot(as.matrix(bayes.nested)[,1])
hdrcde::hdr.boxplot(as.matrix(bayes.nested)[,2])
hist(as.matrix(bayes.nested)[,4])
hist(as.matrix(bayes.nested)[,4], 50)
for ( i in 1:4){
hist(nested.mat[,i], 50, main = colnames(nested.mat)[i])
}
nested.mat <- as.matrix(bayes.nested)
for ( i in 1:4){
hist(nested.mat[,i], 50, main = colnames(nested.mat)[i])
}
?hdr.den
plot(hdr.den[,i], 50, main = colnames(nested.mat)[i])
plot(hdrcde::hdr.den[,i], 50, main = colnames(nested.mat)[i])
for ( i in 1:4){
plot(hdrcde::hdr.den[,i], 50, main = colnames(nested.mat)[i])
}
for ( i in 1:4){
plot(hdrcde::hdr.den(nested.mat[,i], 50, main = colnames(nested.mat)[i]))
}
i
i<-2
plot(hdrcde::hdr.den(nested.mat[,i], 50, main = colnames(nested.mat)[i]))
?hdrbw
?hdr
nested.modes <- apply(nested.mat, 2,
function(x){hdrcde::hdr(x)$mode})
nested.modes
Pastes
summary(m.nested)
overall.mean <- mean(Pastes$strength)
level.1.mu <- tapply(Pastes$strength, Pastes$cask, mean)
level.2.mu <- tapply(Pastes$strength, Pastes$batch, mean)
# the variances of those means (and the overall variance)
overall.var <- var(Pastes$strength)
level.1.var <- var(level.1.mu)
level.2.var <- var(level.2.mu)
# collate the variances among means at each level
# i.e. these are the naive summary random effects.
level.variances <- c(L1 = level.1.var,
L2 = level.2.var,
Overall = overall.var)
overall.mean <- mean(Pastes$strength)
level.0.mu <- tapply(Pastes$strength, Pastes$sample, mean)
level.1.mu <- tapply(Pastes$strength, Pastes$cask, mean)
level.2.mu <- tapply(Pastes$strength, Pastes$batch, mean)
# the variances of those means (and the overall variance)
overall.var <- var(Pastes$strength)
level.0.var <- var(level.0.mu)
level.1.var <- var(level.1.mu)
level.2.var <- var(level.2.mu)
# collate the variances among means at each level
# i.e. these are the naive summary random effects.
level.variances <- c(L0 = level.0.mu,
L1 = level.1.var,
L2 = level.2.var,
Overall = overall.var)
level.variances
level.1.mu <- tapply(Pastes$strength, Pastes$cask, mean)
level.0.mu <- tapply(Pastes$strength, Pastes$sample, mean)
level.0.mu]
level.0.mu
level.0.var <- var(level.0.mu)
level.variances <- c(L0 = level.0.var,
L1 = level.1.var,
L2 = level.2.var,
Overall = overall.var)
level.variances
summary(m.nested)
mean(Pastes$strength)
